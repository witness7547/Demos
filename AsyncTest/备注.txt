Recognize CPU-Bound and I/O-Bound Work
The first two examples of this guide showed how you can use async and await for I/O-bound and CPU-bound work. 
It's key that you can identify when a job you need to do is I/O-bound or CPU-bound, because it can greatly 
affect the performance of your code and could potentially lead to misusing certain constructs.
Here are two questions you should ask before you write any code:

Will your code be "waiting" for something, such as data from a database?
If your answer is "yes", then your work is I/O-bound.

Will your code be performing a very expensive computation?
If you answered "yes", then your work is CPU-bound.

If the work you have is I/O-bound, use async and await without Task.Run. You should not use the Task Parallel Library. 
The reason for this is outlined in the Async in Depth article.

If the work you have is CPU-bound and you care about responsiveness, use async and await but spawn the work off
 on another thread with Task.Run. If the work is appropriate for concurrency and parallelism, you should also 
 consider using the Task Parallel Library.

Additionally, you should always measure the execution of your code. For example, you may find yourself in a situation
 where your CPU-bound work is not costly enough compared with the overhead of context switches when multithreading.
  Every choice has its tradeoff, and you should pick the correct tradeoff for your situation.